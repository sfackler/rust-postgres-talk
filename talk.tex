\documentclass{beamer}

\usepackage{minted}

\title{Rust-Postgres}
\subtitle{An idiomatic, native Postgres driver}
\author[sfackler]{Steven Fackler - sfackler}
\date{July 31, 2014}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Outline}
    \tableofcontents
\end{frame}

\section{Background}
\subsection{PostgreSQL}

\begin{frame}{What's PostgreSQL?}
	\includegraphics[height=2cm]{postgres_logo.pdf}

	\begin{quote}
		PostgreSQL is a powerful, open source object-relational database system. It has more than 15 years of active development and a proven architecture that has earned it a strong reputation for reliability, data integrity, and correctness.
	\end{quote}
\end{frame}

\subsection{Rust-Postgres}

\section{Overview}
\subsection{Usage}

\begin{frame}[fragile]{Connecting}
	Connect with a standard psql-style URI:
	\begin{minted}{rust}
use postgres::{PostgresConnection, NoSsl};
let url = "postgresql://sfackler@localhost:15410/mydb";
let conn = try!(
        PostgresConnection::connect(url, &NoSsl));
	\end{minted}	
\end{frame}

\begin{frame}[fragile]{Connecting}
	Unix sockets are supported as well:
	\begin{minted}{rust}
use postgres::{PostgresConnection, NoSsl};
let url = "postgresql://sfackler@%2Frun%2Fpostgres/mydb";
let conn = try!(
        PostgresConnection::connect(url, &NoSsl));
	\end{minted}	
\end{frame}

\begin{frame}[fragile]{Connecting}
	Alternatively, pass a `PostgresConnectParams' struct:
	\begin{minted}{rust}
use postgres::{PostgresConnection, NoSsl,
               PostgresConnectParams, TargetUnix};
let params = PostgresConnectParams {
    target: TargetUnix(Path::new("/run/postgres")),
    port: Some(1234),
    .....
};
let conn = try!(
        PostgresConnection::connect(params, &NoSsl));
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Statement Preparation}
    Queries must first be \emph{prepared} before they can be executed.

    They may be parameterized. Parameters are denoted by \verb!$n!, and are
    1-indexed.
    \begin{minted}{rust}
let query = "SELECT name, height
             FROM people
             WHERE age < $1";
let stmt = try!(conn.prepare(query));
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Execution}
    The \verb!execute! method takes a slice of values to bind to the query
    parameters and returns the number of rows modified.
    \begin{minted}{rust}
let query = "UPDATE users SET name = $1
             WHERE age = $2";
let stmt = try!(conn.prepare(query));
let rows_updated = try!(stmt.execute(
        [&"Steven", &Some(24i32)]));
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Querying}
    \verb!query! is similar to \verb!execute! but it returns an iterator over
    the rows returned by a query. Columns may be accessed by index or name.
    \begin{minted}{rust}
let query = "SELECT name, age FROM users
             WHERE age < $1";
let stmt = try!(conn.prepare(query));
for row in try!(stmt.query([&18i32])) {
    let name: String = row.get(0u);
    let age: Option<i32> = row.get("age");
    println!("{} is {}", name, age);
}
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Parameterization}
    \begin{center}
        Use it. Seriously.
    \end{center}
\end{frame}

\begin{frame}[fragile]{Parameterization}
    \begin{minted}{rust}
fn update_grade(conn: &PostgresConnection,
                name: &str, grade: f32)
                -> PostgresResult<()> {
    let query = format!("UPDATE students SET grade = {}
                         WHERE name = '{}'",
                        grade, name);
    try!(stmt.batch_execute(query.as_slice()));
    Ok(())
}
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Parameterization}
    \begin{minted}{rust}
let name = "Robert'); DROP TABLE Students;--";
let grade = 100f32;
update_grade(&conn, name, grade);
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Parameterization}
    \begin{minted}{rust}
fn update_grade(conn: &PostgresConnection,
                name: &str, grade: f32)
                -> PostgresResult<Student> {
    let query = "UPDATE students SET grade = $1
                 WHERE name = $1";
    let stmt = try!(conn.prepare(query));
    try!(stmt.update([&grade, &name]));
    Ok(())
}
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Transactions}
    Transactions are managed by the \verb!PostgresTransaction! object:
    \begin{minted}{rust}
let trans = try!(conn.transaction());
let stmt = try!(trans.prepare(...));
....

if the_coast_is_clear {
    trans.set_commit();
}

try!(trans.finish()); // COMMIT / ROLLBACK here
    \end{minted}
\end{frame}

\subsection{Design}

\begin{frame}{RAII and Lifetimes are Awesome}
\end{frame}

\begin{frame}{Strict Typing}
    \begin{enumerate}
        \item Rust-Postgres differs from many drivers in 
    \end{enumerate}
\end{frame}

\begin{frame}{Extensibility}
    Postgres allows for extensions which define new types and operations.

    Rust-Postgres
\end{frame}

\begin{frame}[fragile]{Type Conversion}
    All conversions are done through two traits
    \begin{minted}{rust}
pub trait ToSql {
    fn to_sql(&self, ty: &PostgresType)
              -> PostgresResult<(Format,
                                 Option<Vec<u8>>)>;
} 

pub trait FromSql {
    fn from_sql(y: &PostgresType,
                raw: &Option<Vec<u8>>)
                -> PostgresResult<Self>;
}
    \end{minted}
\end{frame}

\subsection{Macros}

\begin{frame}[fragile]{Compile Time Checks}
    Compile time checks are awesome, but SQL opens up a series of issues that
    won't be discovered until runtime.
    \begin{itemize}
        \item Invalid syntax \mint{sql}|SELECT * FORM foo|
        \item Parameter count mismatch
        \begin{minted}{rust}
try!(conn.execute("UPDATE foo SET a = $1
                        WHERE b = $2",
                  [&1i32]));
        \end{minted}
        \item Schema mismatch \mint{sql}|SELECT nmae FROM users|
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Syntax Extensions to the Rescue}
    Link against PostgreSQL's query parser, and have it do the heavy lifting!
    \begin{minted}{rust}
let query = sql!("SELECT * FORM foo");
    \end{minted}
    \begin{verbatim}
test.rs:8:18: 8:35 error: Invalid syntax at
    position 10: syntax error at or near "FORM"
test.rs:8     let query = sql!("SELECT * FORM foo");
                               ^~~~~~~~~~~~~~~~~~~
    \end{verbatim}
\end{frame}

\begin{frame}[fragile]{Syntax Extensions to the Rescue}
    \begin{minted}{rust}
try!(execute!(conn,
              "UPDATE foo SET a = $1
                WHERE b = $2",
              &1i32));
    \end{minted}
    \begin{verbatim}
test.rs:7:1: 10:23 error: Expected 2 query parameters
        but got 1
test.rs:7 try!(execute!(conn,
test.rs:8               "UPDATE foo SET a = $1
test.rs:9                 WHERE b = $2",
test.rs:10               &1i32));
    \end{verbatim}
\end{frame}

\section{Future}

\begin{frame}{What's Missing}
    Rust-Postgres defines the basics, but much of the infrastructure on top
    is still missing.
    \begin{itemize}
        \item Connection Pool - There is a pool in Rust-Postgres but it's no
        where near sufficient.
        \item ORM - Syntax extensions could allow for a very nice ORM system.
    \end{itemize}
\end{frame}

\begin{frame}{That's It!}
    \begin{center}
        Questions?
    \end{center}
\end{frame}

\end{document}
